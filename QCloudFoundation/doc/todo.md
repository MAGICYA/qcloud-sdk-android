#### 2017.5.17

好久没动这个core库了，现在提出几点要修改的需求

- 请求优先级代替CMD、LOAD

之前使用CMD和LOAD的初衷是为了不让LOAD型的任务对CMD类型的任务造成阻塞，然而也保留了请求的优先级设置，应该来说使用请求优先级就完全可以实现不让耗时任务阻塞命令型任务，且实现方式会更加优雅。
另外一种情况是如果在所有的并发均被耗时任务占用后，命令型任务不受并发控制限制，也就是说，并发控制只是针对耗时任务。

**已完成** ：不高于中优先级任务之和不大于A，不高于高优先级任务之和不大于B，且A>B，则保证高优先级任务不会受中、低优先级任务的阻塞。

- promise机制、同步异步之间的取舍

promise机制当然是一个理想的方向，而异步和同步之间则优先选择异步。因此在


#### 2017.5.18
- OkHttp3的Response解析问题

将整个解析过程分为两步，第一步是解析HTTP返回码，如果是合适的返回码则继续解析Response Body，否则不再进行解析。

**已完成**

- 返回Body是一个两级的JSON，在利用FastJSON进行解析时，需要些内部类。这很繁琐和不美观。

可以将后台返回的多级JSON转化为单级的JSON，然后利用FastJson进行解析即可。

**已完成**：目前支持不超过两级的JSON数据。

- 在取消请求时，对于阻塞任务的取消处理。

如果用户取消了业务请求，那么该请求附带的所有阻塞任务必须全部取消。

- 签名的处理。目前签名是通过在多处地方扔参数，然后统一生成的，这种方式下业务类的build方法中需要指定哪些参数是需要扔进去的，感觉不是很自然，并且在处理单次和多次有效签名时不是自然。

这里有多种处理的方式：1、多处扔参数，统一处理（当前处理方式）：优点：通用性比较好，基本上所有的签名算法都可以统一这样做。2、因为签名是针对于请求的，那么其实我们是对请求进行签名，那么在设计时，我们完全可以针对不同的业务进行专属的签名。优点：这种方式更符合逻辑，且不需要再业务类的build方法中指定哪些参数是需要扔的，但是需要定义一个业务的基类，签名算法从基类中获取部分参数来进行签名。（为了签名，就要将所有业务定义一个基类，且需要定义获取签名参数的方法，感觉很丑陋，且有点重了）；3、同样采取多处扔参数，然后由CredentialProvider类进行统一处理，并且将参数和算法进行分离，这样可以很方便的定义单次有效签名算法、60s有效签名算法、以及1h有效签名算法。

**已完成**：最终采用了第三种方式。（单次有效签名、60s有效签名、3600s有效签名）

- **签名处理2**：看东西要看到本质，万变不离其宗。何为签名：校验用户HTTP请求的合法性，那么参数必然是HTTP请求了。

- **签名处理3**： 

#### 2017.5.20
- 日志库的处理。需要将所有的日志统一使用slf4j的方式来处理

**已解决**

- 异常处理。之前的异常处理太粗糙，这里需要进行优化。是一个简单没有技术含量的东西，但需要仔细。

- OkHttp3的Request Body是否能够为空

**已解决：**遵循http标准协议 

- 请求增加地域参数

**已解决**

- 增加host的构建，而不是直接指定

**已解决**

在cos v4服务中，每个请求的host并不是一成不变的，如上传host为 region.file.myqcloud.com，而下载域名为bucket-appid.cos[region].myqcloud.com。而在cos s3中所有请求的host的格式均为 bucket-appid.region.myqcloud.com

#### 2017.5.21

- 需要支持三级Body的JSON返回包解析

**已解决** 现在支持了所有高阶JSON解析

#### 2017.5.22

- 需要支持UA设置

**已解决**

- 如果请求是一个多级的JSON字符串时，这时候单独的bodyKeyValue总是会当成一个单级的JSON，而无法满足要求。这时可有两种处理方式，1、将后一级的JSON转化为字符串作为上一级的value；2、或者定义一些等级信息（如key[] = key[1]、key[2]）来进行解析；

**现解决方式**：这里参考了Stone的处理方式，采用了第一种方式进行处理，这种方式将map转化为String作为第一级的value值。缺点是key值和value值都交给了用户，SDK无法进行控制，在customHeader下还好，因为key-value都由用户定义是合理的。

- 需要支持字节数组和流上传

**已解决**

- 需要支持S3签名算法

**已解决**

- 需要支持xml的request和result的序列化

**已解决**



- 回包返回头部

**已解决**

- SHA1值和MD5值

**已解决**

- 计算签名需要在OkHttp3的Request类上进行，因为一些头部是OkHttp3帮生成的，且签名时可能会用到这些头部。

这里需要将签名的计算和其他耗时操作分开，先计算其他的，最后计算签名的；

**额**这里和预想的很不一样，自己开始以为调用Request.Builder.build()方法后就会直接生成所有的头部，后来发现并不是这样。这些头部是OkHttp3在发送时设置的，调用build()方法后并不是最终的头部信息。

自己再次进行了实验，response.request().header()中也并没有Date、Content-length等信息，这几乎可以说明，Content-length、Date也并不会在request中设置，而应该是在更底层进行设置。

**已解决**

- 对于用户传入的参数必须经过检查，如path 不可以 连续两个 '/'等...

- 需要可以直接设置host

**已解决**

- 需要解决返回正确和错误的xml文件解析

**已解决**


- 需要根据用户设置签名header的情况来增加header


- 修改重试策略

**已解决**  通过定义Interceptor解决


- 进度监听器

**已解决**  在各个RequestBodySerializer中设置进度监听，而不是在QCloudHttpRequest中进行设置

- http code = 204时，包含了request body导致OkHttp3解析Response时直接抛异常

**部分解决** 利用Interceptor对Response进行改写。虽然这样比直接catch异常来的优雅，但是还是有缺陷，因为实际上丢弃了回包中除了http code之外所有的信息。以后的处理方式应该是在OkHttp3抛出异常前修改，使其满足OkHttp3对回包解析的要求，这样保留了回包的header字段，这才是完美的解决方案。

#### 2017.6.6

- 用户的取消处理

用户的取消处理是一个很有意思的东西，这里有个原则需要遵守，无论结果如何，只要是用户调用了发送接口（异步），那么就必须有且仅有一次回调。这里必须对okhttp3有个测试：
1、正在数据上行时取消；2、数据上行完成，等待数据下行时取消。注意okhttp是否会抛出异常或者回调什么接口。


#### 2017.6.7

- fast-json解析问题，在身份证识别时，FaceSideMessageList和NationSideMessageList的json key都是result_list，这会导致解析冲突。

**已解决** 将FaceSideMessage和NationSideMesssage合二为一，统一为IdCardMessage。但感觉这只是一种规避方案，不最好的解决方式。

- 增加下载的进度监听

**已解决**

- 增加下载部分文件接口

**已解决**

- QCloudRequest增加参数检查接口

**底层库先不支持**

- 下载失败时的错误解析：签名超时是返回的xml，文件不存在却返回了json，真是无语

**先通过header的返回值处理**



